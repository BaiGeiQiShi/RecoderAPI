replace$return (isZero)?NaN:I;
replace$return (isZero)?NaN:NaN;
replace$return (isZero)?NaN:INF;
replace$return (isZero)?NaN:ONE;
replace$return (isZero)?NaN:ZERO;
replace$return (isNaN)?NaN:INF;
replace$return (isInfinite)?NaN:INF;
replace$return (isZero)?NaN:divisor;
replace$return (divisor)?NaN:INF;
replace$return (isZero)?NaN:isNaN;
replace$return (isZero)?I:INF;
replace$return (isZero)?INF:INF;
replace$return (isZero)?ONE:INF;
replace$return (isZero)?ZERO:INF;
replace$return (isZero)?divisor:INF;
replace$return (NaN)?NaN:INF;
replace$return (isZero)?NaN:imaginary;
replace$return (isZero)?NaN:real;
replace$return NaN;
replace$return (ZERO)?NaN:INF;
replace$return (isZero)?isZero:INF;
replace$return (isZero)?NaN:I.INF;
replace$return (isZero)?NaN:NaN.INF;
replace$return (isZero)?NaN:INF.INF;
replace$return (isZero)?NaN:ONE.INF;
replace$return (isZero)?NaN:ZERO.INF;
replace$return (isZero)?NaN:conjugate().INF;
replace$return (isZero)?NaN:negate().INF;
replace$return (isZero)?NaN:acos().INF;
replace$return (isZero)?NaN:asin().INF;
replace$return (isZero)?NaN:atan().INF;
replace$return (isZero)?NaN:cos().INF;
replace$return (isZero)?NaN:cosh().INF;
replace$return (isZero)?NaN:exp().INF;
replace$return (isZero)?NaN:log().INF;
replace$return (isZero)?NaN:sin().INF;
replace$return (isZero)?NaN:sinh().INF;
replace$return (isZero)?NaN:sqrt().INF;
replace$return (isZero)?NaN:sqrt1z().INF;
replace$return (isZero)?NaN:tan().INF;
replace$return (isZero)?NaN:tanh().INF;
replace$return (INF)?NaN:INF;
replace$return (Complex)(isZero)?NaN:INF;
replace$return (isZero)?NaN:I.isZero;
replace$return (isZero)?NaN:NaN.isZero;
replace$return (isZero)?NaN:INF.isZero;
replace$return (isZero)?NaN:ONE.isZero;
replace$return (isZero)?NaN:ZERO.isZero;
replace$return (isZero)?NaN:conjugate().isZero;
replace$return (isZero)?NaN:negate().isZero;
replace$return (isZero)?NaN:acos().isZero;
replace$return (isZero)?NaN:asin().isZero;
replace$return (isZero)?NaN:atan().isZero;
replace$return (isZero)?NaN:cos().isZero;
replace$return (isZero)?NaN:cosh().isZero;
replace$return (isZero)?NaN:exp().isZero;
replace$return (isZero)?NaN:log().isZero;
replace$return (isZero)?NaN:sin().isZero;
replace$return (isZero)?NaN:sinh().isZero;
replace$return (isZero)?NaN:sqrt().isZero;
replace$return (isZero)?NaN:sqrt1z().isZero;
replace$return (isZero)?NaN:tan().isZero;
replace$return (isZero)?NaN:tanh().isZero;
replace$return (isZero)?NaN:I.NaN;
replace$return (isZero)?NaN:NaN.NaN;
replace$return (isZero)?NaN:INF.NaN;
replace$return (isZero)?NaN:ONE.NaN;
replace$return (isZero)?NaN:ZERO.NaN;
replace$return (isZero)?NaN:conjugate().NaN;
replace$return (isZero)?NaN:negate().NaN;
replace$return (isZero)?NaN:acos().NaN;
replace$return (isZero)?NaN:asin().NaN;
replace$return (isZero)?NaN:atan().NaN;
replace$return (isZero)?NaN:cos().NaN;
replace$return (isZero)?NaN:cosh().NaN;
replace$return (isZero)?NaN:exp().NaN;
replace$return (isZero)?NaN:log().NaN;
replace$return (isZero)?NaN:sin().NaN;
replace$return (isZero)?NaN:sinh().NaN;
replace$return (isZero)?NaN:sqrt().NaN;
replace$return (isZero)?NaN:sqrt1z().NaN;
replace$return (isZero)?NaN:tan().NaN;
replace$return (isZero)?NaN:tanh().NaN;
replace$return (imaginary)?NaN:INF;
replace$return isZero;
replace$return (isZero)?NaN:isZero;
replace$return null;
replace$return (isZero)?isNaN:INF;
replace$return (!isInfinite())?ZERO:NaN;
replace$return INF;
replace$return (isNaN.INF)?NaN:INF;
replace$return (isInfinite.INF)?NaN:INF;
replace$return (isZero.INF)?NaN:INF;
replace$return (isNaN().INF)?NaN:INF;
replace$return (isInfinite().INF)?NaN:INF;
replace$return (isZero)?null:INF;
replace$return (isNaN.isZero)?NaN:INF;
replace$return (isInfinite.isZero)?NaN:INF;
replace$return (isZero.isZero)?NaN:INF;
replace$return (isNaN().isZero)?NaN:INF;
replace$return (isInfinite().isZero)?NaN:INF;
replace$return createComplex((real / divisor), (imaginary / divisor));
replace$return (isZero)?NaN:null;
replace$return (isNaN.NaN)?NaN:INF;
replace$return (isInfinite.NaN)?NaN:INF;
replace$return (isZero.NaN)?NaN:INF;
replace$return (isNaN().NaN)?NaN:INF;
replace$return (isInfinite().NaN)?NaN:INF;
replace$return (isZero)?imaginary:INF;
replace$return (isZero)?NaN:-isZero;
replace$return (isZero)?NaN:this.isZero;
replace$return (isZero)?this.isZero:INF;
replace$return (isZero)?NaN:-INF;
replace$return (isZero)?(Complex)divisor:INF;
replace$return (isZero)?NaN:this.NaN;
replace$return (isZero)?NaN:-NaN;
replace$return (real / divisor);
replace$return (isZero)?NaN:this.INF;
delete:1
replace$return (isZero)?NaN:(isZero)?NaN:INF;
replace$return (isZero)?this.NaN:INF;
replace$return (isZero)?this.INF:INF;
replace$return (imaginary / divisor);
replace$return (isZero)?this:INF;
replace$return (Complex)isZero;
insert-before$return NaN;
insert-before$if(isNaN()){ return NaN;}
insert-before$if(isInfinite()){ return NaN;}
replace$return (isZero)?(Complex)isZero:INF;
replace$return !isInfinite();
replace$return (isZero)?NaN:-I;
replace$return (isZero)?NaN:-ONE;
replace$return (isZero)?NaN:-ZERO;
replace$return (isZero)?(Complex)NaN:INF;
replace$return ((isZero == null))?NaN:INF;
replace$return (isZero + Double.isNaN(divisor));
replace$return (isZero)?(Complex)INF:INF;
replace$return (Complex)NaN;
replace$return Double.isNaN(divisor);
replace$return (isZero)?NaN:Double.I;
replace$return (isZero)?NaN:Double.NaN;
replace$return (isZero)?NaN:Double.INF;
replace$return (isZero)?NaN:Double.ONE;
replace$return (isZero)?NaN:Double.ZERO;
replace$return (-isZero)?NaN:INF;
replace$return "null";
replace$return ((isZero != null))?NaN:INF;
replace$return ((isZero == NaN))?NaN:INF;
replace$return ((NaN == null))?NaN:INF;
insert-before$return null;
replace$return divisor;
replace$return ((INF == null))?NaN:INF;
replace$return Double.isInfinite(divisor);
replace$return ((NaN == NaN))?NaN:INF;
replace$return (-NaN)?NaN:INF;
replace$return (isZero)?I.NaN:INF;
replace$return (isZero)?NaN.NaN:INF;
replace$return (isZero)?INF.NaN:INF;
replace$return (isZero)?ONE.NaN:INF;
replace$return (isZero)?ZERO.NaN:INF;
replace$return (isZero)?conjugate().NaN:INF;
replace$return (isZero)?negate().NaN:INF;
replace$return (isZero)?acos().NaN:INF;
replace$return (isZero)?asin().NaN:INF;
replace$return (isZero)?atan().NaN:INF;
replace$return (isZero)?cos().NaN:INF;
replace$return (isZero)?cosh().NaN:INF;
replace$return (isZero)?exp().NaN:INF;
replace$return (isZero)?log().NaN:INF;
replace$return (isZero)?sin().NaN:INF;
replace$return (isZero)?sinh().NaN:INF;
replace$return (isZero)?sqrt().NaN:INF;
replace$return (isZero)?sqrt1z().NaN:INF;
replace$return (isZero)?tan().NaN:INF;
replace$return (isZero)?tanh().NaN:INF;
replace$return (-INF)?NaN:INF;
replace$return ((isZero == 0d))?NaN:INF;
replace$return ((isZero == isZero))?NaN:INF;
replace$return (Double.isNaN)?NaN:INF;
replace$return (Double.isInfinite)?NaN:INF;
replace$return (Double.isZero)?NaN:INF;
replace$return (isZero)?NaN:(Complex)divisor;
replace$return (isZero)?NaN:(isZero)?NaN:isZero;
replace$return (isZero)?I.isZero:INF;
replace$return (isZero)?NaN.isZero:INF;
replace$return (isZero)?INF.isZero:INF;
replace$return (isZero)?ONE.isZero:INF;
replace$return (isZero)?ZERO.isZero:INF;
replace$return (isZero)?conjugate().isZero:INF;
replace$return (isZero)?negate().isZero:INF;
replace$return (isZero)?acos().isZero:INF;
replace$return (isZero)?asin().isZero:INF;
replace$return (isZero)?atan().isZero:INF;
replace$return (isZero)?cos().isZero:INF;
replace$return (isZero)?cosh().isZero:INF;
replace$return (isZero)?exp().isZero:INF;
replace$return (isZero)?log().isZero:INF;
replace$return (isZero)?sin().isZero:INF;
replace$return (isZero)?sinh().isZero:INF;
replace$return (isZero)?sqrt().isZero:INF;
replace$return (isZero)?sqrt1z().isZero:INF;
replace$return (isZero)?tan().isZero:INF;
replace$return (isZero)?tanh().isZero:INF;
replace$return (isZero)?NaN:(isZero)?NaN:NaN;
replace$return ((isZero == INF))?NaN:INF;
replace$return (isZero)?I.INF:INF;
replace$return (isZero)?NaN.INF:INF;
replace$return (isZero)?INF.INF:INF;
replace$return (isZero)?ONE.INF:INF;
replace$return (isZero)?ZERO.INF:INF;
replace$return (isZero)?conjugate().INF:INF;
replace$return (isZero)?negate().INF:INF;
replace$return (isZero)?acos().INF:INF;
replace$return (isZero)?asin().INF:INF;
replace$return (isZero)?atan().INF:INF;
replace$return (isZero)?cos().INF:INF;
replace$return (isZero)?cosh().INF:INF;
replace$return (isZero)?exp().INF:INF;
replace$return (isZero)?log().INF:INF;
replace$return (isZero)?sin().INF:INF;
replace$return (isZero)?sinh().INF:INF;
replace$return (isZero)?sqrt().INF:INF;
replace$return (isZero)?sqrt1z().INF:INF;
replace$return (isZero)?tan().INF:INF;
replace$return (isZero)?tanh().INF:INF;
replace$return (isZero)?NaN:-divisor;
replace$return 0;
replace$return ((NaN == 0d))?NaN:INF;
replace$return ((NaN != null))?NaN:INF;
replace$return ((INF != null))?NaN:INF;
insert-before$return createComplex((real / divisor), (imaginary / divisor));
replace$return (isZero)?NaN:(Complex)isZero;
wrap$if((divisor == 0d)){ 
replace$return ((NaN == isZero))?NaN:INF;
replace$return (isZero)?isZero:(isZero)?NaN:INF;
insert-before$return (!isInfinite())?ZERO:NaN;
replace$return ((INF == NaN))?NaN:INF;
replace$return (isZero)?NaN:divisor.INF;
replace$return (isZero)?NaN:divisor.NaN;
replace$return ((isZero == divisor))?NaN:INF;
replace$return (isZero)?NaN:(isZero)?isZero:INF;
replace$return ((INF == isZero))?NaN:INF;
replace$return ((NaN == INF))?NaN:INF;
replace$return ((INF == INF))?NaN:INF;
replace$return (isZero)?NaN:I.divisor;
replace$return (isZero)?NaN:NaN.divisor;
replace$return (isZero)?NaN:INF.divisor;
replace$return (isZero)?NaN:ONE.divisor;
replace$return (isZero)?NaN:ZERO.divisor;
replace$return (isZero)?NaN:conjugate().divisor;
replace$return (isZero)?NaN:negate().divisor;
replace$return (isZero)?NaN:acos().divisor;
replace$return (isZero)?NaN:asin().divisor;
replace$return (isZero)?NaN:atan().divisor;
replace$return (isZero)?NaN:cos().divisor;
replace$return (isZero)?NaN:cosh().divisor;
replace$return (isZero)?NaN:exp().divisor;
replace$return (isZero)?NaN:log().divisor;
replace$return (isZero)?NaN:sin().divisor;
replace$return (isZero)?NaN:sinh().divisor;
replace$return (isZero)?NaN:sqrt().divisor;
replace$return (isZero)?NaN:sqrt1z().divisor;
replace$return (isZero)?NaN:tan().divisor;
replace$return (isZero)?NaN:tanh().divisor;
replace$return; 
replace$return (Double.NaN)?NaN:INF;
replace$return ((INF == divisor))?NaN:INF;
replace$return (isZero)?NaN:divisor.isZero;
replace$return ((NaN == divisor))?NaN:INF;
replace$return (isZero)?NaN:!isZero;
replace$return (divisor.INF)?NaN:INF;
replace$return (!isZero)?NaN:INF;
replace$return (isZero)?NaN:!INF;
replace$return (divisor.NaN)?NaN:INF;
replace$return (isZero)?NaN:Double.isZero;
replace$return (-isNaN)?NaN:INF;
replace$return (-isInfinite)?NaN:INF;
replace$return ((isZero != NaN))?NaN:INF;
replace$continue; 
replace$return (isZero)?NaN:((isZero == null))?NaN:INF;
wrap$if(!isInfinite()){ 
insert-before$return; 
replace$return (isZero)?NaN:(NaN + NaN);
replace$return (isZero)?NaN:((INF == null))?NaN:INF;
replace$return (isZero)?NaN:((NaN == null))?NaN:INF;
wrap$if(isZero){ 
wrap$if((isNaN || Double.isNaN(divisor))){ 
replace$return (isZero)?NaN:((isZero == 0d))?NaN:INF;
